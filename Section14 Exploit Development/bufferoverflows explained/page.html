<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>BufferOverflows Explained</title>
</head><body><b><span style="color: #ff0000">What is virtual address space?</span></b><br/>
<br/>
In computing, a virtual address space(VAS) or address space is the set of ranges of virtual addresses that an operating system makes available to a process.<br/>
<br/>
(https://en.wikipedia.org/wiki/Virtual_address_space#:~:text=In%20computing%2C%20a%20virtual%20address,makes%20available%20to%20a%20process.)<br/>
<br/>
let's examine that.<br/>
<br/>
<br/>
<img height="454" src="image.png" width="500"/><br/>
<br/>
<ul><li><b>Kernel Space</b></li>
</ul>
<br/>
The kernel space can be accessed by user processes only through the use of system calls that are requests in a Unix-like operating system such as input/output (I/O) or process creation.<br/>
<ul><li><b>User Space</b></li>
</ul>
<br/>
The user space is a computational resource allocated to a user, and it is a resource that the executing program can directly access. This space can be categorized into some segments.<br/>
<br/>
<b>Stack</b> <br/>
<br/>
<br/>
<br/>
This area is devoted to storing all the data needed by a function call in a program. Calling a function is the same as pushing the called function execution onto the top of the stack, and once that function completes, the results are returned popping the function off the stack. The dataset pushed for function call is named a stack frame, and it contains the following data.<br/>
<ul><li>the arguments (parameter values) passed to the routine</li>
</ul>
<ul><li>the return address back to the routine’s caller</li>
</ul>
<ul><li>space for the local variables of the routine</li>
</ul>
<br/>
<br/>
<img height="788" src="image 2.png" width="800"/><br/>
<br/>
<br/>
<br/>
<b>it runs very fast because the stack pointer register simply tracks the top of the stack</b>.<br/>
<br/>
<b>Heap</b> <br/>
<br/>
The Heap is the segment where dynamic memory allocation usually takes place. This area commonly begins at the end of the BSS segment and grows upwards to higher memory addresses. In C, it’s managed by malloc/new, free/delete.<br/>
<br/>
<br/>
<b>BSS ( Block Started by Symbol )</b> <br/>
<br/>
Uninitialized data segment, often called the BSS segment. Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing. For instance, a variable declared as static int i; would be allocated to the BSS segment.<br/>
<br/>
<br/>
<b>Data</b> <br/>
<br/>
The data segment contains initialized global and static variables which have a pre-defined value and can be modified. it’s divided into a read-only and a read-write space.<br/>
<br/>
For example, the following C program outside the main<br/>
<br/>
int val = 3;<br/>
char String[] = &quot;Hello World&quot;;<br/>
<br/>
<br/>
<b>Text</b> <br/>
<br/>
A segment in which a machine language instruction is stored. This segment is a read-only space.<br/>
<br/>
<br/>
<br/>
Now in buffer over flow our concern is about the stack then let's dive into that.<br/>
<br/>
<br/>
<br/>
<img src="image 3.png"/><br/>
<br/>
(https://www.udemy.com/course/practical-ethical-hacking/learn/lecture/17128126#overview)<br/>
<br/>
as we can see above explanations stack is store these;<br/>
<br/>
<ul><li>1)the arguments (parameter values) passed to the routine</li>
</ul>
<ul><li>2)the return address back to the routine’s caller</li>
</ul>
<ul><li>3)space for the local variables of the routine</li>
<li/>
<li/>
<li>and stack is able to extend itself through downward. But it must stop when it reachs EBP. In buffer overflow you actually overflow the buffer space and you're reaching over EBP and into something called the EIP.</li>
<li/>
</ul>
<ul>Now EIP is a pointer address or a return address, so what we can do is we can use this address to point to directions that we instruct. These directions actually going to be malicious code that gives us a reverse shell.</ul>
<br/>
<br/>
<br/>
<br/>
<br/>
<img src="image 4.png"/><br/>
<br/>
<br/>
Spiking, is a method that we use to find the vulnerable part of the program.<br/>
in Fuzzing we're going to send a bunch of characters ar a program and see if we can break it. <br/>
In finding the offset we want to find offset and we use that offset to overwrite the ip that pointer address that we're talking about.<br/>
<br/>
we're going to point out that EIP to our malicious shell code and hopefully we're gonna gain root.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span style="color: #ff0000">Further Reading About Memory<br/>
</span><br/>
(https://www.geeksforgeeks.org/memory-layout-of-c-program/)<br/>
<br/>
(https://en.wikipedia.org/wiki/Virtual_address_space#:~:text=In%20computing%2C%20a%20virtual%20address,makes%20available%20to%20a%20process.)<br/>
<br/>
(https://en.wikipedia.org/wiki/Memory_address)<br/>
<br/>
(https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/)<br/>
<br/>
(https://www.geeksforgeeks.org/mapping-virtual-addresses-to-physical-addresses/)<br/>
<br/>
(https://www.geeksforgeeks.org/memory-layout-of-c-program/)<br/>
<br/>
<br/>
<span style="color: #ff0000">Further Reading About Assembly<br/>
<br/>
</span>(https://inst.eecs.berkeley.edu/~cs161/sp15/discussions/dis06-assembly.pdf)<br/>
<br/>
(https://www.cs.virginia.edu/~evans/cs216/guides/x86.html)</body></html>